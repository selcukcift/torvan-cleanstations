import { NextResponse } from 'next/server';import { promises as fs } from 'fs';import path from 'path';import { prisma } from '@/lib/prisma';import { z } from 'zod';const QcTemplateCreateSchema = z.object({formName: z.string(),formType: z.enum(['Pre-Production Check', 'Production Check', 'Final QC', 'End-of-Line Testing']),version: z.string(),description: z.string(),appliesToProductFamily: z.string(),isActive: z.boolean(),items: z.array(z.object({section: z.string(),checklistItem: z.string(),itemType: z.enum(['PASS_FAIL', 'TEXT_INPUT', 'NUMERIC_INPUT', 'SINGLE_SELECT', 'MULTI_SELECT', 'DATE_INPUT', 'CHECKBOX']),isBasinSpecific: z.boolean(),isRequired: z.boolean(),order: z.number(),})),});type QCTemplate = z.infer<typeof QcTemplateCreateSchema>;async function parseChecklistFile(): Promise<QCTemplate[]> {const filePath = path.join(process.cwd(), 'resources', 'CLP.T2.001.V01 - T2SinkProduction.txt');const fileContent = await fs.readFile(filePath, 'utf-8');const sections = fileContent.split(/SECTION \d+/).slice(1);const templates: QCTemplate[] = [];const sectionMappings = [{ identifier: 'PRE-PRODUCTION CHECK', formType: 'Pre-Production Check', formName: 'T2 Sink Pre-Production Check' },{ identifier: 'SINK PRODUCTION CHECK', formType: 'Production Check', formName: 'T2 Sink Production Check' },{ identifier: 'BASIN PRODUCTION', formType: 'Production Check', formName: 'T2 Basin Production Check' },{ identifier: 'STANDARD PACKAGING & KITS', formType: 'Final QC', formName: 'T2 Sink Final QC & Packaging' },];sections.forEach((sectionText, index) => {const lines = sectionText.trim().split(/\r?\n/).filter(line => line.trim());if (lines.length === 0) return;const header = lines[0].trim();const mapping = sectionMappings.find(m => header.includes(m.identifier));if (!mapping) return;const items: QCTemplate['items'] = [];let order = 1;lines.slice(1).forEach(line => {if (line.includes('☐')) {const checklistItem = line.replace('☐', '').replace(/N\/A$/, '').trim();if (checklistItem) {items.push({section: mapping.formName,checklistItem,itemType: 'PASS_FAIL',isBasinSpecific: checklistItem.toLowerCase().includes('basin'),isRequired: true,order: order++,});}}});if (items.length > 0) {const existingTemplate = templates.find(t => t.formName === mapping.formName);if (existingTemplate) {existingTemplate.items.push(...items);} else {templates.push({...mapping,version: '1.0',description: `Official checklist for ${mapping.formName}`,appliesToProductFamily: 'MDRD_T2_SINK',isActive: true,items,});}}});return templates;}export async function POST() {try {const templates = await parseChecklistFile();for (const templateData of templates) {await prisma.qCFormTemplate.upsert({where: { formName_version: { formName: templateData.formName, version: templateData.version } },update: {...templateData,items: {deleteMany: {},create: templateData.items,},},create: {...templateData,items: {create: templateData.items,},},});}return NextResponse.json({ success: true, message: `Successfully seeded ${templates.length} QC templates.` });} catch (error) {console.error("Failed to seed QC templates:", error);return NextResponse.json({ success: false, message: "An error occurred while seeding the QC templates." }, { status: 500 });}}